Charpter 3&4 标准库类型&数组和指针
======================================
1. 在头文件中，必须总是使用完全限定的标准库名字，因为头文件会被复制粘贴到好多地方。

2. cin>>string,cin为忽略开头空格，找到字符开始读，读到下一个空格就停止，因此cin>>s1>>s2，而getline(cin,string)，遇到换行符就停止，不管在第几个位置遇到。

3. stirng的size操作返回的string::size_type类型，这种自己定义了一套配套类型，是为了让库类型使用与机器无关。所以任何string的size操作结果都要是size_type类型，不要赋给int，而且size_type一般是unsigned，因长度一定为正，所以存储最大长度是int的一倍。

   同样下标访问string时，也是for(string::size_type i=0;....)

   vector也是，不过需要指出来元素类型vector<int>::size_type

4. C++中for循环里，一般不用<号做判断，而是用!=vector.size()，而且这里可以看到，也不会提前存储size()的值，让只执行一边方法，每次都调用size方法，方便vector的动态增加和删除

5. vector中对已存在的元素可以用下标索引，但对下标操作进行赋值，不会添加进任何元素

   但一般还是用各容器都有的iterator来做<br/>
   vector<int>::iterator iter=ivec.begin();<br/>
   \*为解引用操作符，可以用 \*ivec表示ivec[0]

6. const_iterator遍历时只能读取，不能改变值

7. vector使用size_type，数组使用size_t遍历

8. 对指针进行解引用，可以获得指针指向的值或者指向的对象

   指针保存的是另一个对象的地址，eg: \*sp=&s，将s的地址取出来赋给指针sp存储的地址<br/>
   &是取地址操作符，，它作用于一个对象上，返回这个对象的存储地址，取地址操作符只能作用于左值<br/>
   指针的初始化，要么是0/null，要么就是\*p=&object

9. void*可以保存任何类型对象的地址，它表明该指针和一个地址有关，但不知道该地址上具体的类型。

   void*指针只能执行有限的操作，向函数传递void*指针，或者从函数返回这个指针，不允许使用void*指针操作它指向的对象。

10. 其实string \*sp中sp才是声明的指针，而不是 \*sp,\*sp表示对指针sp进行解引用，获取其指向的对象。所以sp=。。是修改指针的值，\*sp是修改指针指向的对象的值

   所以就是<br/>
   \*sp就是使用指针指向的对象<br/>
   sp就是指针（指针本身也是一种类型）<br/>
   所以\*\*spp中的spp就是指向指针的指针，而**spp还是本来要访问的对象

11. 指针和引用的区别<br/>

    引用必须初始化，一开始就初始化<br/>
    另赋值行为差异，给引用赋值为修改关联对象的值。

12. 声明一个数组，数组名自动转换为指向数组第一个元素的指针

13. 数组上的指针相减，隔离机器变化，返回机器类型ptrdiff_t<br/>
    eg: ptrdiff_t len=ip1-ip2;

14. 指向const对象的指针 const int \*ip=&a;

    * 不能通过指针修改指向的对象，但可以变更指向别的const对象，注意，指向别的也必须是const的

    * void\*指针也不能保存const对象，也必须用const void*来保存

    * 允许const指针指向一个非const对象，但不能通过这个指针修改这个值，但允许别的方法去修改这个值，所以一般可以作为形参写成const的，不让传入的函数修改传入的值，所以可以理解为“自以为指向const的指针”，即不能保证const指针指向的对象不能修改，所以都不能通过这个指向const的指针来修改

    const指针 int \*const p=&a;

    * 指针本身的值不能改，不能变更指向别的对象，所以必须在定义时初始化，至于它所指向的对象能不能修改，完全取决于对象的类型

    指向const对象的const指针

    * const int a=10;<br/>
      const int \*const ip =&a;<br/>
      既不允许修改指向的对象的值，也不能修改指向别的对象  

15. C的标准库函数string.h总是默认字符串以null结束，也就是‘\0’

16. int a[]=new int[10];声明一个动态数组，内置类型是未初始化的，而加上圆括号，int a[]=new int[10]();就初始化了，都初始化为0，而string s[]=new string[10];类类型这么声明就已经初始化了

17. 多维数组


补充
==============================================
*
