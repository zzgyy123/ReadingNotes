Charpter 5&6 表达式&语句
======================================
1. 前置自增/后置自增

   只有必要时才使用后置操作符，即i++，因为前置所做的操作更少，只需要加1返回结果即可，后置需要先保存原来的副本

       while(iter!=ivec.end())
          cout<<*ivec++<<endl;
  这里*ivec++等价于*(ivec++)，后自增返回之前的副本，然后自增，虽然过程是先自增，再返回，但返回的自增之前的值。（简洁既是美）

2. p->a()等价于(\*p).a()

   p是一个指针，\*p取得对象，然后点操作符调用方法，这里必须有括号，因为\*操作符的优先级低

   由于这种加括号很容易忘记，所以用了一种的新的操作符->代替

3. size_of()方法返回类型长度，返回值类型size_t,而size_of(\*p)返回p所指的对象的大小

4. new表达式会返回指向新建对象的指针
       int \*pi=new int;
   撤销时使用
       delete pi;释放pi所指向的对象的空间
       删除之后，立即把指针赋为0，防止悬垂指针(dangling pointer).
5. 2.9.2节使用预处理变量避免重复包含头文件

   6.14节介绍使用预处理变量有条件的执行测试的代码，eg:
       #inndef NDEBUG
       cerr<<"error.."<<endl;
       #endif

   之后debug时不定义NDEBUG,发布时
       $ CC -DNDEBUG main.c
   即可定义DNDEBUG,即不再执行调试代码

补充
==============================================
*
